#!/usr/bin/env python

"""
This script translates trade files generated by the Clang tracing plugin for
CUDA into read/write/atomic access sets on a CTA basis and writes the result
into an SQLite database.
"""

from sortedcontainers import SortedDict, SortedList
import sqlite3
import struct
import os
import sys

class RangeList:
    """Add and query non-overlapping intervals. Intervals are semi-closed, e.g.
    the interval [1, 3) contains the points {1, 2}.
    """
    def __init__(self, init = None):
        self.data = SortedList(init, key = lambda x: x[0])

    def add(self, start, end):
        left = self.data.bisect_right((start, 0))
        if left > 0:
            if self.data[left-1][1] >= start:
                start = self.data[left-1][0]
                left -= 1

        right = self.data.bisect_right((end, 0))
        if right > 0:
            if self.data[right-1][1] >= end:
                end = self.data[right-1][1]

        for _ in range(right-left):
            self.data.pop(left)

        self.data.add((start, end))

    def list(self):
        return list(self.data)

    def iter(self):
        return self.data.islice(start = 0)

def read_entry(f):
    kinds={0:'loads', 1:'stores', 2:'atomics'}
    mark = f.read(1)
    if mark == b'\x00':
        buf = f.read(2)
        size, = struct.unpack('H', buf)
        kernelname = f.read(size).decode('utf-8')
        return 'kernel', {
                    'name': kernelname,
                }
    elif mark == b'\xff':
        buf = f.read(24)
        f1, f2, f3 = struct.unpack('QQQ', buf)
        smid = (f1 >> 32)
        type = (f1 & 0xf0000000) >> 28
        size = (f1 & 0x0fffffff)
        addr = f2
        ctax = (f3 >> 32) & 0xffffffff
        ctay = (f3 >> 16) & 0x0000ffff
        ctaz = (f3) & 0x0000ffff
        return 'record', {
                    'smid': smid,
                    'size': size,
                    'type': type,
                    'kind': kinds[type],
                    'addr': addr,
                    'cta': (ctax, ctay, ctaz),
                    'count': 1,
                }
    elif mark == b'\xfe':
        buf = f.read(24 + 2)
        f1, f2, f3, count = struct.unpack('QQQH', buf)
        smid = (f1 >> 32)
        type = (f1 & 0xf0000000) >> 28
        size = (f1 & 0x0fffffff)
        addr = f2
        ctax = (f3 >> 32) & 0xffffffff
        ctay = (f3 >> 16) & 0x0000ffff
        ctaz = (f3) & 0x0000ffff
        return 'record', {
                    'smid': smid,
                    'size': size,
                    'type': type,
                    'kind': kinds[type],
                    'addr': addr,
                    'cta': (ctax, ctay, ctaz),
                    'count': count,
                }
    elif mark == b'':
        return 'eof', None
    else:
        return 'invalid', { 'byte': mark, 'pos': f.tell() }

def open_database(path):
    db = sqlite3.connect(path, timeout = 600)
    db.execute('PRAGMA synchronous = OFF;')
    db.execute('PRAGMA foreign_keys = ON;')
    #db.set_trace_callback(print)

    db.execute("""CREATE TABLE IF NOT EXISTS kernels
            -- Contains a unique id for each kernel launch of an application run.
            -- 'tag' is the unique name of an application run.
            -- One use case is to encode application parameters with it, e.g.
            -- 'matmul-n-512' could be used as the tag for a matrix multiply with
            -- a problem size of 512.
            (id INTEGER PRIMARY KEY, tag TEXT, kernel TEXT, launch INTEGER,
             UNIQUE(id, tag, kernel, launch));""")
    db.execute("""CREATE TABLE IF NOT EXISTS ctas
            -- Contains non-overlapping semi-closed intervals of addresses accessed
            -- by a CTA during a kernel launch (identified by 'kernel').
            -- E.g. the record 10, 2,3,4, 0, 500,700 indicates that during kernel 10,
            -- the cta with index (2, 3, 4) read addresses 500 (inclusive) to
            -- 700 (exclusive), or {500 .. 699}.
            -- Kind: 0 = loads, 1 = stores, 2 = atomics
            (kernel INTEGER, x INTEGER, y INTEGER, z INTEGER, kind INTEGER,
             start INTEGER, stop INTEGER,
             FOREIGN KEY(kernel) REFERENCES kernels(id) ON DELETE CASCADE);""")
    return db

def write_kernel(db, kernel, tag):
    id = db.execute("INSERT INTO kernels (tag, kernel, launch)"
        "  VALUES(?, ?, ?);", (tag, kernel['name'], kernel['launch'])).lastrowid
    for (x, y, z) in kernel['ctas']:
        for (k, kn) in [(0,'loads'), (1,'stores'), (2,'atomics')]:
            for (start, stop) in kernel['ctas'][(x,y,z)][kn].iter():
                db.execute("INSERT INTO ctas"
                    " (kernel, x,y,z, kind, start, stop)"
                    " VALUES(?, ?,?,?, ?, ?,?);",
                    (id, x,y,z, k, start, stop))


# structure: { name: string, launch: num, ctas: { (x,y,z) : {loads, stores, atomics} } }
# (db, tag, kernel, entry) -> kernel
def handle_kernel(kernel, entry):
    launch = 0 if kernel == None else kernel['launch'] + 1
    return {
            'name': entry['name'],
            'launch': launch,
            'ctas': {},
    }

def handle_record(kernel, entry):
    if kernel == None:
        raise Exception("record encountered without prepared kernel")
    cta = entry['cta']
    if cta not in kernel['ctas']:
        kernel['ctas'][cta] = {
                    'loads': RangeList(),
                    'stores': RangeList(),
                    'atomics': RangeList(),
                }
    start = entry['addr']
    stop = start + entry['size'] * entry['count']
    kernel['ctas'][cta][entry['kind']].add(start, stop)
    return kernel

def main(argv):
    if len(argv) < 4:
        print("usage: cta-sets.py <trace-file> <tag> <database>")
        return 1
    _, tracePath, tag, dbPath = argv
    db = open_database(dbPath)
    stdin = sys.stdin.buffer
    trace = stdin if tracePath == '-' else open(tracePath, 'rb')
    with trace:
        kernel = None 

        # read file and process each kernel as it comes
        header = trace.read(10)

        v2 =  b'\x19\x43\x55\x44\x41\x54\x52\x41\x43\x45'
        v3 =  b'\x1a\x43\x55\x44\x41\x54\x52\x41\x43\x45'
        if header != v2 and header != v3:
            print("invalid header")
            return 1

        while True:
            kind, entry = read_entry(trace)
            if kind == 'kernel':
                if kernel != None: write_kernel(db, kernel, tag)
                kernel = handle_kernel(kernel, entry)
            elif kind == 'record':
                kernel = handle_record(kernel, entry)
            elif kind == 'eof':
                db.commit()
                break
            else:
                print('invalid entry in trace file')
                return 1
        if kernel != None: write_kernel(db, kernel, tag)
        db.commit()

if __name__ == "__main__":
    sys.exit(main(sys.argv))
